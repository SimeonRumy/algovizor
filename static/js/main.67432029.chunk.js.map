{"version":3,"sources":["PathVizor/Node/Node.jsx","algorithms/commonMethods.js","algorithms/dijkstra.js","algorithms/astar.js","algorithms/bfs.js","algorithms/dfs.js","algorithms/recursiveDivision.jsx","NavBar/NavBar.jsx","ButtonBar/ButtonBar.jsx","PathVizor/PathVizor.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","cost","extraClassName","id","className","Component","calculateCostIncured","nodesVisited","getUnvisitedNeighbors","node","grid","neighbors","push","length","getAllNeighbors","filter","neighbor","isVisited","resetNode","distance","Infinity","previousNode","dijkstra","startNode","finishNode","console","log","visitedNodesInOrder","unvisitedNodes","nodes","getAllNodes","i","sortNodesByDistance","closestNode","shift","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","astar","setEuclideanDistance","getAllNodesWithEuclideanDistance","euclideanDistance","Math","sqrt","pow","bfs","dfs","finishNodeFound","resetAllNodes","exploreUnvisitedNeighbors","apply","recursiveDivision","width","height","divide","x","y","isHorizontal","wx","floor","random","wy","px","py","dx","dy","isPassingNode","getTopBottomNeighbors","getLeftRigthNeighbors","nx","ny","w","h","chooseOrientation","NavBar","state","algoNumber","buttonText","handleAlgoChange","bind","runAlgo","text","number","setState","onDijkstra","onAstar","onBFS","onDFS","onReset","Navbar","bg","variant","Brand","href","Toggle","aria-controls","Collapse","Nav","Link","NavDropdown","title","Item","onClick","Form","inline","Button","ButtonBar","costNumber","onSetStartButtonClick","onSetFinishButtonClick","onSetWAllsButtonClick","onSetCostlyNodes","resetWalls","generateMaze","resetCostlyNodes","DropdownButton","as","ButtonGroup","Dropdown","PathVizor","mouseIsPressed","setWallsButtonIsPressed","setStartButtonIsPressed","setFinishButtonIsPresed","setCostButtonIsPressed","startNodeRow","startNodeColumn","finishNodeRow","finishNodeColumn","shortestPathDistance","numberOfNodesVisted","costIncured","calculateRowNumber","currentRow","calculateColumnNumber","initNode","setupIntialGrid","newGrid","reactToMouseAction","toggleWallInGrid","resetGoalNodes","toggleStartNodeInGrid","toggleFinishNodeInGrid","updateNodeCostInGrid","visitedNodesOrdered","nodesOfTheShortestPathOrdered","setTimeout","animateShortestPath","document","getElementById","start","end","searchAndReplace","algo","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animateAlgorithm","resetStatState","setCostNodeToNumberInGrid","visualizeAlgorithm","resetGrid","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","documentElement","clientWidth","round","clientHeight","newCost","slice","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.67432029.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n      cost,\n    } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n        ? 'node-start'\n        : isWall\n          ? 'node-wall'\n          : (cost === 1)\n            ? 'node-costly1'\n            : (cost === 2)\n              ? 'node-costly2'\n              : (cost === 3)\n                ? 'node-costly3'\n                : \"\"\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}>\n      </div>\n    );\n  }\n}\n","// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        nodesInShortestPathOrder.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}\n\nexport function calculateCostIncured(nodesVisited) {\n    var cost = 0;\n    for (const node of nodesVisited) {\n        cost += node.cost;\n    }\n    return cost;\n}\n\nexport function getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    getAllNeighbors(node, neighbors, grid);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\n\nfunction getAllNeighbors(node, neighbors, grid) {\n    const { col, row } = node;\n    if (col > 0)\n        neighbors.push(grid[row][col - 1]);\n    if (row < grid.length - 1)\n        neighbors.push(grid[row + 1][col]);\n    if (col < grid[0].length - 1)\n        neighbors.push(grid[row][col + 1]);\n    if (row > 0)\n        neighbors.push(grid[row - 1][col]);\n}\n\nexport function resetNode(node) {\n    node.distance = Infinity;\n    node.isVisited = false;\n    node.previousNode = null;\n}","\nimport { getUnvisitedNeighbors, resetNode } from '../algorithms/commonMethods';\n\n\nexport function dijkstra(grid, startNode, finishNode) {\n  console.log(startNode)\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getAllNodes(grid);\n  startNode.distance = 0;\n  var i = 0\n  for (i = 0; unvisitedNodes.length; i++) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode.isWall) continue; // Ignore wall\n    if (closestNode.distance === Infinity) return visitedNodesInOrder; // If distance === infinity we are trapped\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1 + neighbor.cost;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      resetNode(node);\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n\n","import { getUnvisitedNeighbors, resetNode } from '../algorithms/commonMethods';\n\nexport function astar(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    const unvisitedNodes = getAllNodesWithEuclideanDistance(grid, finishNode);\n    startNode.distance = 0;\n    while (!!unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n        // If we encounter a wall, we skip it.\n        if (closestNode.isWall) continue;\n        // If the closest node is at a distance of infinity,\n        // we must be trapped and should therefore stop.\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        if (closestNode === finishNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => ((nodeA.distance - nodeB.distance)));\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance - node.euclideanDistance + 1 + neighbor.cost + neighbor.euclideanDistance;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getAllNodesWithEuclideanDistance(grid, finishNode) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            resetNode(node);\n            setEuclideanDistance(node, finishNode);\n            console.log(node)\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction setEuclideanDistance(node, finishNode) {\n    node.euclideanDistance = Math.sqrt(Math.pow((node.row - finishNode.row), 2) + Math.pow((node.col - finishNode.col), 2));\n}\n\n\n\n// function updateUnvisitedNeighbors(node, grid) {\n//     const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n//     for (const neighbor of unvisitedNeighbors) {\n//         neighbor.distance = node.distance + 1 + neighbor.cost + neighbor.euclideanDistance;\n//         neighbor.previousNode = node;\n//     }\n// }","import { getUnvisitedNeighbors, resetNode } from '../algorithms/commonMethods';\n\nexport function bfs(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    const unvisitedNodes = getAllNodes(grid);\n    startNode.distance = 0;\n    while (!!unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n        const closestNode = unvisitedNodes.shift();\n        // If we encounter a wall, we skip it.\n        if (closestNode.isWall) continue;\n        // If the closest node is at a distance of infinity,\n        // we must be trapped and should therefore stop.\n        if (closestNode.distance === Infinity) return visitedNodesInOrder;\n        closestNode.isVisited = true;\n        visitedNodesInOrder.push(closestNode);\n        if (closestNode === finishNode) return visitedNodesInOrder;\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => ((nodeA.distance - nodeB.distance)));\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            resetNode(node);\n            console.log(node)\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction setEuclideanDistance(node, finishNode) {\n    node.euclideanDistance = Math.sqrt(Math.pow((node.row - finishNode.row), 2) + Math.pow((node.col - finishNode.col), 2));\n}\n","import { getUnvisitedNeighbors, resetNode } from '../algorithms/commonMethods';\n\nexport function dfs(grid, startNode, finishNode) {\n    finishNodeFound = false;\n    var visitedNodesInOrder = [];\n    const unvisitedNodes = resetAllNodes(grid);\n    visitedNodesInOrder = exploreUnvisitedNeighbors(startNode, grid, finishNode);\n    return visitedNodesInOrder;\n}\n\nvar finishNodeFound = false;\n\nfunction exploreUnvisitedNeighbors(node, grid, finishNode) {\n    var visitedNodesInOrder = [];\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n\n        if (neighbor.isWall) continue;\n        if (neighbor.isStart) continue;\n        neighbor.isVisited = true;\n        neighbor.previousNode = node;\n        visitedNodesInOrder.push(neighbor);\n        if (neighbor  === finishNode) {\n            finishNodeFound = true; \n            return visitedNodesInOrder;\n        }\n        visitedNodesInOrder.push.apply(visitedNodesInOrder, exploreUnvisitedNeighbors( neighbor, grid, finishNode));\n        if (finishNodeFound) return visitedNodesInOrder;\n    }\n    return visitedNodesInOrder;\n}\n\nfunction resetAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            resetNode(node);\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n","import { getUnvisitedNeighbors, resetNode } from '../algorithms/commonMethods';\n\n//  An implementation of the \"Recursive Division\" algorithm. This is a\n//  kind of fractal maze algorithm, recursively dividing the maze into\n//  smaller and smaller cells. This algorithm stops at the integer\n//  boundary, but theoretically the algorithm could continue infinitely\n//  to smaller and smaller scales.\n// \n//  Note that this algorithm is implemented as a \"wall adder\", rather\n//  than a \"passage carver\", so the meaning of the bits in each cell\n//  is reversed: instead of the S bit (for instance) meaning \"a passage\n//  goes south\", it means \"there is a wall to the south\"\n\nexport function recursiveDivision(grid, startNode, finishNode) {\n    const width = grid[0].length;\n    const height = grid.length;\n    resetAllNodes(grid)\n    return divide(grid, 0, 0, width, height, chooseOrientation(width, height));\n}\n\nfunction chooseOrientation(width, height) {\n    if (width > height) {\n        //vertical \n        return 0;\n    } else if (width < height) {\n        //horizontal\n        return 1;\n    } else {\n        return (Math.floor(Math.random() * 2) === 1) ? 0 : 1;\n    }\n\n}\n\nfunction divide(grid, x, y, width, height, isHorizontal) {\n    var visitedNodesInOrder = [];\n    if (width < 5 || height < 5) return;\n\n    //where will the wall be drawn from?\n    var wx = x + (isHorizontal? 0 : (Math.floor(Math.random() * (width-2))));\n    var wy = y + (isHorizontal? (Math.floor(Math.random() * (height-2))) : 0);\n\n    //where will the passage through the wall exist?\n    const px = wx + (isHorizontal ? Math.floor(Math.random() * width) : 0);\n    const py = wy + (isHorizontal ? 0 : Math.floor(Math.random() * height));\n\n    //what direction will the wall be drawn?\n    const dx = isHorizontal ? 1 : 0\n    const dy = isHorizontal ? 0 : 1\n\n    console.log(isHorizontal)\n    // how long will the wall be?\n    const length = (isHorizontal ? width : height);\n    console.log(length)\n\n    for (var i=0; i<length; i++) {\n\n        if (grid[wy][wx].isPassingNode) {\n            //Problem\n        }\n\n        const neighbors = isHorizontal? getTopBottomNeighbors(grid[wy][wx]) : getLeftRigthNeighbors(grid[wy][wx]);\n        \n        for (const neighbor of neighbors) {\n            if (neighbor.isWall) {\n                if (neighbor.isHorizontal === isHorizontal) {\n                    //Problem\n                }\n            }\n        }\n\n\n        if (wx !== px || wy !== py) {\n            grid[wy][wx].isWall = true;\n            grid[wy][wx].isHorizontal = isHorizontal;\n            visitedNodesInOrder.push(grid[wy][wx]);\n        } else {\n            grid[wy][wx].isPassingNode = true;\n            for (const neighbor of neighbors) {\n                neighbors.isPassingNode = true;\n            }\n        }\n        wx += dx;\n        wy += dy;\n    }\n\n    var nx = x;\n    var ny = y;\n    var w = isHorizontal ? width : wx-x+1;\n    var h = isHorizontal ? wy-y+1 : height;\n    visitedNodesInOrder.push.apply(visitedNodesInOrder, divide(grid, nx, ny, w, h, chooseOrientation(w, h)));\n\n    nx = isHorizontal ? x : wx + 1;\n    ny = isHorizontal ? wy+1 : y;\n    w = isHorizontal ? width : x+width-wx-1;\n    h = isHorizontal ? y+height-wy-1 : height;\n    visitedNodesInOrder.push.apply(visitedNodesInOrder, divide(grid, nx, ny, w, h, chooseOrientation(w, h)));\n\n    return visitedNodesInOrder\n}\n\nfunction getLeftRigthNeighbors(node, grid) {\n    var neighbors = [];\n    const { col, row } = node;\n    if (col < grid[0].length - 1)\n        neighbors.push(grid[row][col + 1]);\n    if (col < grid[0].length - 1)\n        neighbors.push(grid[row][col + 1]);\n    return neighbors\n}\n\nfunction getTopBottomNeighbors(node, grid) {\n    var neighbors = [];\n    const { col, row } = node;\n    if (row < grid.length - 1)\n        neighbors.push(grid[row + 1][col]);\n    if (row > 0)\n        neighbors.push(grid[row - 1][col]);\n    return neighbors\n}\n\nfunction getAllNeighbors(node, neighbors, grid) {\n    const { col, row } = node;\n    if (col > 0)\n        neighbors.push(grid[row][col - 1]);\n    if (row < grid.length - 1)\n        neighbors.push(grid[row + 1][col]);\n    if (col < grid[0].length - 1)\n        neighbors.push(grid[row][col + 1]);\n    if (row > 0)\n        neighbors.push(grid[row - 1][col]);\n}\n\nfunction resetAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            resetNode(node);\n            node.isWall = false;\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\n\nfunction shuffle(array) {\n    var currentIndex = array.length, temporaryValue, randomIndex;\n  \n    // While there remain elements to shuffle...\n    while (0 !== currentIndex) {\n  \n      // Pick a remaining element...\n      randomIndex = Math.floor(Math.random() * currentIndex);\n      currentIndex -= 1;\n  \n      // And swap it with the current element.\n      temporaryValue = array[currentIndex];\n      array[currentIndex] = array[randomIndex];\n      array[randomIndex] = temporaryValue;\n    }\n  \n    return array;\n  }\n  \n","import React, { Component } from 'react';\nimport { Navbar, Nav, NavDropdown, Form, Button } from 'react-bootstrap'\nimport './NavBar.css';\nexport default class NavBar extends Component {\n\n    constructor() {\n        super();\n        this.state = {\n            algoNumber: 0,\n            buttonText: \"\"\n        };\n        this.handleAlgoChange = this.handleAlgoChange.bind(this);\n        this.runAlgo = this.runAlgo.bind(this);\n    }\n\n\n    handleAlgoChange(text, number) {\n        this.setState({ algoNumber: number, buttonText: text })\n    }\n\n    runAlgo(dijkstra, astar, bfs, dfs) {\n        if (this.state.algoNumber === 0) {\n            return dijkstra();\n        } else if (this.state.algoNumber === 1) {\n            return astar();\n        } else if (this.state.algoNumber === 2) {\n            return bfs();\n        } else {\n            return dfs();\n        }\n    }\n\n    render() {\n        const {\n            onDijkstra,\n            onAstar,\n            onBFS,\n            onDFS,\n            onReset,\n        } = this.props;\n\n        return (\n            <div>\n                <Navbar bg=\"dark\" variant=\"dark\">\n                    <Navbar.Brand href=\"#home\">Algo Vizor</Navbar.Brand>\n                    <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\n                    <Navbar.Collapse id=\"basic-navbar-nav\">\n                        <Nav className=\"mr-auto\">\n                            <Nav.Link href=\"#home\">Home</Nav.Link>\n                            <Nav.Link href=\"#link\">About</Nav.Link>\n                            <NavDropdown title=\"Algorithms\" id=\"basic-nav-dropdown\">\n                                <NavDropdown.Item href=\"#action/3.2\" onClick={() => this.handleAlgoChange(\"Dijkstras\", 0)}>Dijkstras</NavDropdown.Item>\n                                <NavDropdown.Item href=\"#action/3.2\" onClick={() => this.handleAlgoChange(\"A-Star\", 1)}>A-Star</NavDropdown.Item>\n                                <NavDropdown.Item href=\"#action/3.3\" onClick={() => this.handleAlgoChange(\"BFS\", 2)}>Breath First Search</NavDropdown.Item>\n                                <NavDropdown.Item href=\"#action/3.3\" onClick={() => this.handleAlgoChange(\"DFS\", 3)}>Depth First Search</NavDropdown.Item>\n                            </NavDropdown>\n                        </Nav>\n                        <Form inline>\n                            <Button className=\"ml-2\" variant=\"outline-success btn-lg\" onClick={() => this.runAlgo(onDijkstra, onAstar, onBFS, onDFS)}>\n                            Run {this.state.buttonText} Algorithm</Button>\n                            <Button className=\"ml-2\" variant=\"outline-danger btn-lg\" onClick={() => onReset()}>Reset Paths</Button>\n                        </Form>\n                    </Navbar.Collapse>\n                </Navbar>\n            </div>\n        );\n    }\n}\n\n","import React, { Component } from 'react';\nimport { Navbar, Nav, NavDropdown, Form, FormControl, Button, DropdownButton, ButtonGroup, Dropdown } from 'react-bootstrap'\n\n\nexport default class ButtonBar extends Component {\n\n    constructor() {\n        super();\n        this.state = {\n            costNumber: 0,\n            buttonText: \"\"\n        };\n    }\n\n    render() {\n        const {\n            onSetStartButtonClick,\n            onSetFinishButtonClick,\n            onSetWAllsButtonClick,\n            onSetCostlyNodes,\n            generateMaze,\n            resetWalls,\n            resetCostlyNodes,\n        } = this.props;\n\n        return (\n            <div>\n                <Navbar bg=\"ligth\" variant=\"ligth\">\n                    <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\n                    <Navbar.Collapse id=\"basic-navbar-nav\">\n                        <Nav className=\"ml-auto\">\n                            <Button className=\"ml-3 mr-3\" variant=\"secondary btn-md\" onClick={() => onSetStartButtonClick()}>Set Start</Button>\n                            <Button className=\"ml-3 mr-3\" variant=\"secondary btn-md\" onClick={() => onSetFinishButtonClick()}>Set Finish</Button>\n\n                            <DropdownButton as={ButtonGroup} className=\"ml-3 mr-3\" title=\"Add Costly Nodes\" id=\"bg-nested-dropdown\" variant=\"secondary btn-md\">\n                                    <Dropdown.Item onClick={() => onSetCostlyNodes()}>Add Nodes</Dropdown.Item>\n                                    <Dropdown.Item onClick={() => resetCostlyNodes()}>Reset Nodes</Dropdown.Item>\n                            </DropdownButton>\n                            <DropdownButton as={ButtonGroup} className=\"ml-3 mr-3\" title=\"Add Walls\" id=\"bg-nested-dropdown\" variant=\"secondary btn-md\">\n                                    <Dropdown.Item onClick={() => onSetWAllsButtonClick()}>Add Nodes</Dropdown.Item>\n                                    <Dropdown.Item onClick={() => resetWalls()}>Reset Nodes</Dropdown.Item>\n                            </DropdownButton>\n\n                            {/* <Button className=\"ml-3 mr-0\" variant=\"secondary btn-md\" onClick={() => generateMaze()}>Generate Maze</Button> */}\n                        </Nav>\n\n                    </Navbar.Collapse>\n                </Navbar>\n            </div >\n        );\n    }\n}","import React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { getNodesInShortestPathOrder, calculateCostIncured } from '../algorithms/commonMethods';\nimport { dijkstra } from '../algorithms/dijkstra';\nimport { astar } from '../algorithms/astar';\nimport { bfs } from '../algorithms/bfs';\nimport { dfs } from '../algorithms/dfs';\nimport { recursiveDivision } from '../algorithms/recursiveDivision';\nimport NavBar from '../NavBar/NavBar'\nimport ButtonBar from '../ButtonBar/ButtonBar'\n\nimport './PathVizor.css';\n\nexport default class PathVizor extends Component {\n\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      setWallsButtonIsPressed: false,\n      setStartButtonIsPressed: false,\n      setFinishButtonIsPresed: false,\n      setCostButtonIsPressed: false,\n      startNodeRow: 10,\n      startNodeColumn: 15,\n      finishNodeRow: 10,\n      finishNodeColumn: 35,\n      shortestPathDistance: 0,\n      numberOfNodesVisted: 0,\n      costIncured: 0\n    };\n  }\n\n  componentDidMount() {\n    const { startNodeRow, startNodeColumn, finishNodeColumn, finishNodeRow } = this.state;\n    const grid = setupIntialGrid(startNodeRow, startNodeColumn, finishNodeColumn, finishNodeRow);\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = this.reactToMouseAction(row, col);\n    this.setState({ grid: newGrid, mouseIsPressed: true });\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = this.reactToMouseAction(row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  reactToMouseAction(row, col) {\n    var newGrid = this.state.grid;\n    if (this.state.setWallsButtonIsPressed) {\n      newGrid = toggleWallInGrid(this.state.grid, row, col);\n    } else if (this.state.setStartButtonIsPressed) {\n      this.resetGoalNodes(true, false)\n      newGrid = this.state.grid\n      newGrid = toggleStartNodeInGrid(newGrid, row, col);\n      this.setState({ startNodeRow: row });\n      this.setState({ startNodeColumn: col });\n    } else if (this.state.setFinishButtonIsPresed) {\n      this.resetGoalNodes(false, true)\n      newGrid = this.state.grid\n      newGrid = toggleFinishNodeInGrid(newGrid, row, col);\n      this.setState({ finishNodeRow: row });\n      this.setState({ finishNodeColumn: col });\n    } else if (this.state.setCostButtonIsPressed) {\n      newGrid = updateNodeCostInGrid(newGrid, row, col);\n    }\n    return newGrid;\n  }\n\n  animateAlgorithm(visitedNodesOrdered, nodesOfTheShortestPathOrdered) {\n    for (let i = 0; i <= visitedNodesOrdered.length; i++) {\n      if (i === visitedNodesOrdered.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesOfTheShortestPathOrdered);\n          this.setState({ numberOfNodesVisted: visitedNodesOrdered.length });\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesOrdered[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesOfTheShortestPathOrdered) {\n    this.setState({ shortestPathDistance: nodesOfTheShortestPathOrdered.length });\n    for (let i = 0; i < this.state.shortestPathDistance; i++) {\n      setTimeout(() => {\n        const node = nodesOfTheShortestPathOrdered[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n      }, 50 * i);\n    }\n  }\n\n  resetGoalNodes(start, end) {\n    var newGrid = this.state.grid;\n    newGrid = this.searchAndReplace(start, newGrid, end);\n    this.setState({ grid: newGrid });\n  }\n\n  searchAndReplace(start, newGrid, end) {\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        if (node.isStart && start) {\n          newGrid = toggleStartNodeInGrid(this.state.grid, node.row, node.col);\n          return;\n        } else if (node.isFinish && end) {\n          newGrid = toggleFinishNodeInGrid(this.state.grid, node.row, node.col);\n          return;\n        }\n      }\n    }\n    return newGrid;\n  }\n\n\n  visualizeAlgorithm(algo) {\n    this.setState({ setStartButtonIsPressed: false, setFinishButtonIsPresed: false, setWallsButtonIsPressed: false })\n    const { grid } = this.state;\n    const { startNodeRow, startNodeColumn, finishNodeColumn, finishNodeRow } = this.state;\n    const startNode = grid[startNodeRow][startNodeColumn];\n    const finishNode = grid[finishNodeRow][finishNodeColumn];\n    const visitedNodesInOrder = algo(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\n    this.setState({costIncured: calculateCostIncured(visitedNodesInOrder)});\n  }\n\n  resetGrid() {\n    this.resetStatState();\n    for (const row of this.state.grid) {\n      for (const node of row) {\n        if (node.isStart) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-start';\n        } else if (node.isFinish) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-finish';\n        } else if (node.isWall) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-wall';\n        } else if (node.cost > 1) {\n          if (node.cost === 1) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-costly1';\n          } else if (node.cost === 2) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-costly2';\n          } else {\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-costly3';\n          }\n        }\n        else {\n          document.getElementById(`node-${node.row}-${node.col}`).className = 'node node';\n        }\n      }\n    }\n  }\n\n  resetWalls() {\n    var newGrid = this.state.grid;\n    for (const row of this.state.grid) {\n      for (const node of row) {\n          if (node.isWall) {\n              newGrid = toggleWallInGrid(newGrid, node.row, node.col);\n          }\n      }\n    }\n    this.setState({ grid: newGrid });\n  }\n\n  resetCostlyNodes() {\n    var newGrid = this.state.grid;\n    for (const row of this.state.grid) {\n      for (const node of row) {\n          if (node.cost > 0) {\n              newGrid = setCostNodeToNumberInGrid(newGrid, node.row, node.col, 0)\n          }\n      }\n    }\n    this.setState({ grid: newGrid });\n  }\n\n  resetStatState() {\n    this.setState({ shortestPathDistance: 0 });\n    this.setState({ numberOfNodesVisted: 0 });\n    this.setState({ costIncured: 0 });\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <>\n        <NavBar\n          onDijkstra={() => this.visualizeAlgorithm(dijkstra)}\n          onAstar={() => this.visualizeAlgorithm(astar)}\n          onBFS={() => this.visualizeAlgorithm(bfs)}\n          onDFS={() => this.visualizeAlgorithm(dfs)}\n          onReset={() => this.resetGrid()}>\n        </NavBar>\n\n        <ButtonBar\n          resetWalls={() => this.resetWalls()}\n          resetCostlyNodes={() => this.resetCostlyNodes()}\n          onSetStartButtonClick={() => this.setState({ setStartButtonIsPressed: true, setFinishButtonIsPresed: false, setWallsButtonIsPressed: false, setCostButtonIsPressed: false })}\n          onSetFinishButtonClick={() => this.setState({ setStartButtonIsPressed: false, setFinishButtonIsPresed: true, setWallsButtonIsPressed: false, setCostButtonIsPressed: false })}\n          onSetWAllsButtonClick={() => this.setState({ setStartButtonIsPressed: false, setFinishButtonIsPresed: false, setWallsButtonIsPressed: true, setCostButtonIsPressed: false })}\n          onSetCostlyNodes={() => this.setState({ setStartButtonIsPressed: false, setFinishButtonIsPresed: false, setWallsButtonIsPressed: false, setCostButtonIsPressed: true })}\n          generateMaze={() => this.visualizeAlgorithm(recursiveDivision)}\n        ></ButtonBar>\n\n        <h4 className=\"distanceLabel\">Shortest distance: {this.state.shortestPathDistance}</h4>\n        <h4 className=\"distanceLabel\">Nodes visited: {this.state.numberOfNodesVisted}</h4>\n        <h4 className=\"distanceLabel\">Cost incured: {this.state.costIncured + this.state.numberOfNodesVisted}</h4>\n\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall, cost } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      cost={cost}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}>\n                    </Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n\n      </>\n    );\n  }\n}\n\n// win.innerWidth || docElem.clientWidth || body.clientWidth\n// win.innerHeight || docElem.clientHeight || body.clientHeight\n// body = doc.getElementsByTagName('body')[0],\n// win = window\n\nfunction setupIntialGrid(startNodeRow, startNodeColumn, finishNodeColumn, finishNodeRow) {\n  const grid = [];\n  for (let row = 0; row < calculateRowNumber(); row++) {\n    const currentRow = [];\n    for (let col = 0; col < calculateColumnNumber(); col++) {\n      currentRow.push(initNode(col, row, startNodeRow, startNodeColumn, finishNodeColumn, finishNodeRow));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n}\n\nconst calculateColumnNumber = () => {\n  var doc = document,\n    docElem = doc.documentElement,\n    width = docElem.clientWidth,\n    numberOfColumns = Math.round((width - 0.05 * width) / 25);\n  return numberOfColumns;\n}\n\nconst calculateRowNumber = () => {\n  var doc = document,\n    docElem = doc.documentElement,\n    height = docElem.clientHeight,\n    numberOfRows = Math.round((height - (0.1 * height) - 120) / 25);\n  return numberOfRows;\n}\n\nconst initNode = (col, row, startNodeRow, startNodeColumn, finishNodeColumn, finishNodeRow) => {\n  return {\n    col,\n    row,\n    isStart: row === startNodeRow && col === startNodeColumn,\n    isFinish: row === finishNodeRow && col === finishNodeColumn,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n    cost: 0\n  };\n};\n\nconst setCostNodeToNumberInGrid = (grid, row, col, newCost) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    cost: newCost,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n\n}\n\nconst updateNodeCostInGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newCost = (node.cost === 0) ? 1 : (node.cost === 1) ? 2 : (node.cost === 2) ? 3 : (node.cost === 3) ? 0 : 0\n  const newNode = {\n    ...node,\n    cost: newCost,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n\n}\n\nconst toggleStartNodeInGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: false,\n    isStart: !node.isStart,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst toggleFinishNodeInGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: false,\n    isFinish: !node.isFinish,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst toggleWallInGrid = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n","import React from 'react';\nimport './App.css';\nimport PathfindingVisualizer from './PathVizor/PathVizor.jsx';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer></PathfindingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}